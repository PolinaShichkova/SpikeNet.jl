        - abstract Pathway
        - 
        - type DensePathway{P} <: Pathway
        0     W::Matrix{Float32}
        -     learn::P
        - end
        - 
        - type SparsePathway{P} <: Pathway
        -     W::SparseMatrixCSC{Float32}
        -     learn::P
        - end
        - 
        - function route_rates!(pre, path::Pathway, post)
        -     Base.LinAlg.BLAS.gemv!('N', 1.0f0, path.W, pre.z, 0.0f0, post.g)
        - end
        - 
        - @generated function route_spikes!(pre, path::DensePathway, post)
        0     decls = []
        0     subst_pre = Dict()
        0     unpack_soa!(decls, subst_pre, pre, :pre, :i, "")
        0     spike_expr = replace(spike(pre), subst_pre)
        - 
        0     subst = Dict()
        0     unpack_soa!(decls, subst, post, :post, :j, "")
        0     subst[:w] = :(w[j,i])
        0     on_spike_expr = replace(on_spike(post), subst)
        0 
        0     gen_func = gen_dense_pathway(decls, spike_expr, on_spike_expr)
        0 #    println(gen_func)
        0     return gen_func
        - end
        - 
        - @generated function learn!{P}(pre, path::DensePathway{P}, post, post2)
        0     subst = Dict()
        0     decls = []
        0     unpack_soa!(decls, subst, pre, :pre, :i, "_pre")
        0     unpack_soa!(decls, subst, post, :post, :j, "_post")
        0     if post2 != Void
        0         unpack_soa!(decls, subst, post2, :post2, :j, "_post")
        -     end
        0     unpack_soa!(decls, subst, P, :(path.learn), :idx, "")
        0     subst[:w] = :(w[j,i])
        0 
        0     learn_expr = replace(learn(P), subst)
        0     gen_func = gen_dense_pathway(decls, :true, learn_expr)
        0     return gen_func
        0 end
        0 
        0 function gen_dense_pathway(decls, test_expr, do_expr)
        0     quote
        0         $(Expr(:meta, :inline))
        0         $(Expr(:meta, :fastmath))
        0         @assert length(pre) == size(path.W, 2)
        0         @assert length(post) == size(path.W, 1)
        0         $(decls...)
        0         w = path.W
        0         for i in 1:length(pre)
        0             @inbounds if $test_expr
        0                 @simd for j in 1:length(post)
        0                     $do_expr
        -                 end
        -             end
        -         end
        -     end
        0 end
        0 
        0 
